{
  "version": 3,
  "sources": ["../../@radix-ui/react-collection/dist/packages/react/collection/src/index.ts", "../../@radix-ui/react-collection/dist/packages/react/collection/src/Collection.tsx", "../../@radix-ui/react-direction/dist/packages/react/direction/src/index.ts", "../../@radix-ui/react-direction/dist/packages/react/direction/src/Direction.tsx", "../../@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/index.ts", "../../@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/RovingFocusGroup.tsx", "../../@radix-ui/react-toggle/dist/packages/react/toggle/src/index.ts", "../../@radix-ui/react-toggle/dist/packages/react/toggle/src/Toggle.tsx", "../../@radix-ui/react-toggle-group/dist/packages/react/toggle-group/src/index.ts", "../../@radix-ui/react-toggle-group/dist/packages/react/toggle-group/src/ToggleGroup.tsx"],
  "sourcesContent": ["export { createCollection } from './Collection';\nexport type { CollectionProps } from './Collection';\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype SlotProps = Radix.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>\u2026</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n", "export {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n} from './Direction';\n", "import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n", "export {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n} from './RovingFocusGroup';\nexport type { RovingFocusGroupProps, RovingFocusItemProps } from './RovingFocusGroup';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const { __scopeRovingFocusGroup, focusable = true, active = false, ...itemProps } = props;\n    const id = useId();\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n", "export {\n  Toggle,\n  //\n  Root,\n} from './Toggle';\nexport type { ToggleProps } from './Toggle';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Toggle\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Toggle';\n\ntype ToggleElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToggleProps extends PrimitiveButtonProps {\n  /**\n   * The controlled state of the toggle.\n   */\n  pressed?: boolean;\n  /**\n   * The state of the toggle when initially rendered. Use `defaultPressed`\n   * if you do not need to control the state of the toggle.\n   * @defaultValue false\n   */\n  defaultPressed?: boolean;\n  /**\n   * The callback that fires when the state of the toggle changes.\n   */\n  onPressedChange?(pressed: boolean): void;\n}\n\nconst Toggle = React.forwardRef<ToggleElement, ToggleProps>((props, forwardedRef) => {\n  const { pressed: pressedProp, defaultPressed = false, onPressedChange, ...buttonProps } = props;\n\n  const [pressed = false, setPressed] = useControllableState({\n    prop: pressedProp,\n    onChange: onPressedChange,\n    defaultProp: defaultPressed,\n  });\n\n  return (\n    <Primitive.button\n      type=\"button\"\n      aria-pressed={pressed}\n      data-state={pressed ? 'on' : 'off'}\n      data-disabled={props.disabled ? '' : undefined}\n      {...buttonProps}\n      ref={forwardedRef}\n      onClick={composeEventHandlers(props.onClick, () => {\n        if (!props.disabled) {\n          setPressed(!pressed);\n        }\n      })}\n    />\n  );\n});\n\nToggle.displayName = NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst Root = Toggle;\n\nexport {\n  Toggle,\n  //\n  Root,\n};\nexport type { ToggleProps };\n", "export {\n  createToggleGroupScope,\n  //\n  ToggleGroup,\n  ToggleGroupItem,\n  //\n  Root,\n  Item,\n} from './ToggleGroup';\nexport type {\n  ToggleGroupSingleProps,\n  ToggleGroupMultipleProps,\n  ToggleGroupItemProps,\n} from './ToggleGroup';\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Toggle } from '@radix-ui/react-toggle';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToggleGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOGGLE_GROUP_NAME = 'ToggleGroup';\n\ntype ScopedProps<P> = P & { __scopeToggleGroup?: Scope };\nconst [createToggleGroupContext, createToggleGroupScope] = createContextScope(TOGGLE_GROUP_NAME, [\n  createRovingFocusGroupScope,\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype ToggleGroupElement = ToggleGroupImplSingleElement | ToggleGroupImplMultipleElement;\ninterface ToggleGroupSingleProps extends ToggleGroupImplSingleProps {\n  type: 'single';\n}\ninterface ToggleGroupMultipleProps extends ToggleGroupImplMultipleProps {\n  type: 'multiple';\n}\n\nconst ToggleGroup = React.forwardRef<\n  ToggleGroupElement,\n  ToggleGroupSingleProps | ToggleGroupMultipleProps\n>((props, forwardedRef) => {\n  const { type, ...toggleGroupProps } = props;\n\n  if (type === 'single') {\n    const singleProps = toggleGroupProps as ToggleGroupImplSingleProps;\n    return <ToggleGroupImplSingle {...singleProps} ref={forwardedRef} />;\n  }\n\n  if (type === 'multiple') {\n    const multipleProps = toggleGroupProps as ToggleGroupImplMultipleProps;\n    return <ToggleGroupImplMultiple {...multipleProps} ref={forwardedRef} />;\n  }\n\n  throw new Error(`Missing prop \\`type\\` expected on \\`${TOGGLE_GROUP_NAME}\\``);\n});\n\nToggleGroup.displayName = TOGGLE_GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ToggleGroupValueContextValue = {\n  type: 'single' | 'multiple';\n  value: string[];\n  onItemActivate(value: string): void;\n  onItemDeactivate(value: string): void;\n};\n\nconst [ToggleGroupValueProvider, useToggleGroupValueContext] =\n  createToggleGroupContext<ToggleGroupValueContextValue>(TOGGLE_GROUP_NAME);\n\ntype ToggleGroupImplSingleElement = ToggleGroupImplElement;\ninterface ToggleGroupImplSingleProps extends ToggleGroupImplProps {\n  /**\n   * The controlled stateful value of the item that is pressed.\n   */\n  value?: string;\n  /**\n   * The value of the item that is pressed when initially rendered. Use\n   * `defaultValue` if you do not need to control the state of a toggle group.\n   */\n  defaultValue?: string;\n  /**\n   * The callback that fires when the value of the toggle group changes.\n   */\n  onValueChange?(value: string): void;\n}\n\nconst ToggleGroupImplSingle = React.forwardRef<\n  ToggleGroupImplSingleElement,\n  ToggleGroupImplSingleProps\n>((props: ScopedProps<ToggleGroupImplSingleProps>, forwardedRef) => {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange = () => {},\n    ...toggleGroupSingleProps\n  } = props;\n\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange,\n  });\n\n  return (\n    <ToggleGroupValueProvider\n      scope={props.__scopeToggleGroup}\n      type=\"single\"\n      value={value ? [value] : []}\n      onItemActivate={setValue}\n      onItemDeactivate={React.useCallback(() => setValue(''), [setValue])}\n    >\n      <ToggleGroupImpl {...toggleGroupSingleProps} ref={forwardedRef} />\n    </ToggleGroupValueProvider>\n  );\n});\n\ntype ToggleGroupImplMultipleElement = ToggleGroupImplElement;\ninterface ToggleGroupImplMultipleProps extends ToggleGroupImplProps {\n  /**\n   * The controlled stateful value of the items that are pressed.\n   */\n  value?: string[];\n  /**\n   * The value of the items that are pressed when initially rendered. Use\n   * `defaultValue` if you do not need to control the state of a toggle group.\n   */\n  defaultValue?: string[];\n  /**\n   * The callback that fires when the state of the toggle group changes.\n   */\n  onValueChange?(value: string[]): void;\n}\n\nconst ToggleGroupImplMultiple = React.forwardRef<\n  ToggleGroupImplMultipleElement,\n  ToggleGroupImplMultipleProps\n>((props: ScopedProps<ToggleGroupImplMultipleProps>, forwardedRef) => {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange = () => {},\n    ...toggleGroupMultipleProps\n  } = props;\n\n  const [value = [], setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange,\n  });\n\n  const handleButtonActivate = React.useCallback(\n    (itemValue: string) => setValue((prevValue = []) => [...prevValue, itemValue]),\n    [setValue]\n  );\n\n  const handleButtonDeactivate = React.useCallback(\n    (itemValue: string) =>\n      setValue((prevValue = []) => prevValue.filter((value) => value !== itemValue)),\n    [setValue]\n  );\n\n  return (\n    <ToggleGroupValueProvider\n      scope={props.__scopeToggleGroup}\n      type=\"multiple\"\n      value={value}\n      onItemActivate={handleButtonActivate}\n      onItemDeactivate={handleButtonDeactivate}\n    >\n      <ToggleGroupImpl {...toggleGroupMultipleProps} ref={forwardedRef} />\n    </ToggleGroupValueProvider>\n  );\n});\n\nToggleGroup.displayName = TOGGLE_GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ToggleGroupContextValue = { rovingFocus: boolean; disabled: boolean };\n\nconst [ToggleGroupContext, useToggleGroupContext] =\n  createToggleGroupContext<ToggleGroupContextValue>(TOGGLE_GROUP_NAME);\n\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype ToggleGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToggleGroupImplProps extends PrimitiveDivProps {\n  /**\n   * Whether the group is disabled from user interaction.\n   * @defaultValue false\n   */\n  disabled?: boolean;\n  /**\n   * Whether the group should maintain roving focus of its buttons.\n   * @defaultValue true\n   */\n  rovingFocus?: boolean;\n  loop?: RovingFocusGroupProps['loop'];\n  orientation?: RovingFocusGroupProps['orientation'];\n  dir?: RovingFocusGroupProps['dir'];\n}\n\nconst ToggleGroupImpl = React.forwardRef<ToggleGroupImplElement, ToggleGroupImplProps>(\n  (props: ScopedProps<ToggleGroupImplProps>, forwardedRef) => {\n    const {\n      __scopeToggleGroup,\n      disabled = false,\n      rovingFocus = true,\n      orientation,\n      dir,\n      loop = true,\n      ...toggleGroupProps\n    } = props;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToggleGroup);\n    const direction = useDirection(dir);\n    const commonProps = { role: 'group', dir: direction, ...toggleGroupProps };\n    return (\n      <ToggleGroupContext scope={__scopeToggleGroup} rovingFocus={rovingFocus} disabled={disabled}>\n        {rovingFocus ? (\n          <RovingFocusGroup.Root\n            asChild\n            {...rovingFocusGroupScope}\n            orientation={orientation}\n            dir={direction}\n            loop={loop}\n          >\n            <Primitive.div {...commonProps} ref={forwardedRef} />\n          </RovingFocusGroup.Root>\n        ) : (\n          <Primitive.div {...commonProps} ref={forwardedRef} />\n        )}\n      </ToggleGroupContext>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * ToggleGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'ToggleGroupItem';\n\ntype ToggleGroupItemElement = ToggleGroupItemImplElement;\ninterface ToggleGroupItemProps extends Omit<ToggleGroupItemImplProps, 'pressed'> {}\n\nconst ToggleGroupItem = React.forwardRef<ToggleGroupItemElement, ToggleGroupItemProps>(\n  (props: ScopedProps<ToggleGroupItemProps>, forwardedRef) => {\n    const valueContext = useToggleGroupValueContext(ITEM_NAME, props.__scopeToggleGroup);\n    const context = useToggleGroupContext(ITEM_NAME, props.__scopeToggleGroup);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(props.__scopeToggleGroup);\n    const pressed = valueContext.value.includes(props.value);\n    const disabled = context.disabled || props.disabled;\n    const commonProps = { ...props, pressed, disabled };\n    const ref = React.useRef<HTMLDivElement>(null);\n    return context.rovingFocus ? (\n      <RovingFocusGroup.Item\n        asChild\n        {...rovingFocusGroupScope}\n        focusable={!disabled}\n        active={pressed}\n        ref={ref}\n      >\n        <ToggleGroupItemImpl {...commonProps} ref={forwardedRef} />\n      </RovingFocusGroup.Item>\n    ) : (\n      <ToggleGroupItemImpl {...commonProps} ref={forwardedRef} />\n    );\n  }\n);\n\nToggleGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ToggleGroupItemImplElement = React.ElementRef<typeof Toggle>;\ntype ToggleProps = Radix.ComponentPropsWithoutRef<typeof Toggle>;\ninterface ToggleGroupItemImplProps extends Omit<ToggleProps, 'defaultPressed' | 'onPressedChange'> {\n  /**\n   * A string value for the toggle group item. All items within a toggle group should use a unique value.\n   */\n  value: string;\n}\n\nconst ToggleGroupItemImpl = React.forwardRef<ToggleGroupItemImplElement, ToggleGroupItemImplProps>(\n  (props: ScopedProps<ToggleGroupItemImplProps>, forwardedRef) => {\n    const { __scopeToggleGroup, value, ...itemProps } = props;\n    const valueContext = useToggleGroupValueContext(ITEM_NAME, __scopeToggleGroup);\n    const singleProps = { role: 'radio', 'aria-checked': props.pressed, 'aria-pressed': undefined };\n    const typeProps = valueContext.type === 'single' ? singleProps : undefined;\n    return (\n      <Toggle\n        {...typeProps}\n        {...itemProps}\n        ref={forwardedRef}\n        onPressedChange={(pressed) => {\n          if (pressed) {\n            valueContext.onItemActivate(value);\n          } else {\n            valueContext.onItemDeactivate(value);\n          }\n        }}\n      />\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = ToggleGroup;\nconst Item = ToggleGroupItem;\n\nexport {\n  createToggleGroupScope,\n  //\n  ToggleGroup,\n  ToggleGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { ToggleGroupSingleProps, ToggleGroupMultipleProps, ToggleGroupItemProps };\n"],
  "mappings": "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",
  "names": ["createCollection", "name", "PROVIDER_NAME", "createCollectionContext", "createCollectionScope", "createContextScope", "CollectionProviderImpl", "useCollectionContext", "collectionRef", "current", "itemMap", "Map", "CollectionProvider", "props", "children", "ref", "React", "useRef", "$6vYhU$react", "COLLECTION_SLOT_NAME", "CollectionSlot", "forwardRef", "forwardedRef", "context", "scope", "composedRefs", "useComposedRefs", "ITEM_SLOT_NAME", "ITEM_DATA_ATTR", "CollectionItemSlot", "itemData", "useEffect", "set", "delete", "useCollection", "getItems", "useCallback", "collectionNode", "orderedNodes", "Array", "from", "querySelectorAll", "items", "values", "orderedItems", "sort", "a", "b", "indexOf", "Provider", "Slot", "ItemSlot", "DirectionContext", "React", "undefined", "useDirection", "localDir", "globalDir", "React", "DirectionContext", "ENTRY_FOCUS", "EVENT_OPTIONS", "bubbles", "cancelable", "GROUP_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createRovingFocusGroupContext", "createRovingFocusGroupScope", "createContextScope", "RovingFocusProvider", "useRovingFocusContext", "RovingFocusGroup", "React", "props", "forwardedRef", "$98Iye$createElement", "__scopeRovingFocusGroup", "RovingFocusGroupImpl", "currentTabStopId", "currentTabStopIdProp", "groupProps", "ref", "composedRefs", "useComposedRefs", "direction", "useDirection", "dir", "setCurrentTabStopId", "useControllableState", "prop", "defaultProp", "defaultCurrentTabStopId", "onChange", "onCurrentTabStopIdChange", "isTabbingBackOut", "setIsTabbingBackOut", "handleEntryFocus", "useCallbackRef", "onEntryFocus", "getItems", "isClickFocusRef", "node", "current", "addEventListener", "removeEventListener", "tabStopId", "orientation", "outline", "style", "composeEventHandlers", "onMouseDown", "onFocus", "event", "isKeyboardFocus", "target", "currentTarget", "entryFocusEvent", "CustomEvent", "dispatchEvent", "defaultPrevented", "items", "filter", "item", "focusable", "activeItem", "find", "active", "currentItem", "id", "candidateItems", "Boolean", "candidateNodes", "map", "focusFirst", "onBlur", "ITEM_NAME", "RovingFocusGroupItem", "itemProps", "useId", "context", "isCurrentTabStop", "preventDefault", "onItemFocus", "onKeyDown", "key", "shiftKey", "onItemShiftTab", "focusIntent", "getFocusIntent", "undefined", "reverse", "currentIndex", "indexOf", "loop", "wrapArray", "slice", "setTimeout", "MAP_KEY_TO_FOCUS_INTENT", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "PageUp", "Home", "PageDown", "End", "getDirectionAwareKey", "includes", "candidates", "PREVIOUSLY_FOCUSED_ELEMENT", "document", "activeElement", "candidate", "focus", "array", "startIndex", "_", "index", "length", "Root", "Item", "NAME", "Toggle", "React", "props", "forwardedRef", "pressed", "pressedProp", "buttonProps", "setPressed", "useControllableState", "prop", "onChange", "onPressedChange", "defaultProp", "defaultPressed", "$5AXX7$createElement", "disabled", "undefined", "composeEventHandlers", "onClick", "TOGGLE_GROUP_NAME", "createToggleGroupContext", "createToggleGroupScope", "createContextScope", "createRovingFocusGroupScope", "useRovingFocusGroupScope", "ToggleGroup", "React", "forwardRef", "props", "forwardedRef", "toggleGroupProps", "type", "singleProps", "$jFibJ$react", "multipleProps", "Error", "ToggleGroupValueProvider", "useToggleGroupValueContext", "ToggleGroupImplSingle", "value", "valueProp", "toggleGroupSingleProps", "setValue", "useControllableState", "prop", "defaultProp", "defaultValue", "onChange", "onValueChange", "__scopeToggleGroup", "useCallback", "ToggleGroupImplMultiple", "toggleGroupMultipleProps", "handleButtonActivate", "itemValue", "prevValue", "handleButtonDeactivate", "filter", "ToggleGroupContext", "useToggleGroupContext", "ToggleGroupImpl", "rovingFocusGroupScope", "direction", "useDirection", "dir", "commonProps", "role", "rovingFocus", "ITEM_NAME", "ToggleGroupItem", "valueContext", "context", "pressed", "includes", "disabled", "ref", "useRef", "ToggleGroupItemImpl", "itemProps", "undefined", "typeProps", "onItemActivate", "onItemDeactivate", "Root", "Item"]
}
