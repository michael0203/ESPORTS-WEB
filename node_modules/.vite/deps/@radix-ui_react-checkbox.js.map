{
  "version": 3,
  "sources": ["../../@radix-ui/react-use-previous/dist/packages/react/use-previous/src/index.ts", "../../@radix-ui/react-use-previous/dist/packages/react/use-previous/src/usePrevious.tsx", "../../@radix-ui/react-use-size/dist/packages/react/use-size/src/index.ts", "../../@radix-ui/react-use-size/dist/packages/react/use-size/src/useSize.tsx", "../../@radix-ui/react-label/dist/packages/react/label/src/index.ts", "../../@radix-ui/react-label/dist/packages/react/label/src/Label.tsx", "../../@radix-ui/react-checkbox/dist/packages/react/checkbox/src/index.ts", "../../@radix-ui/react-checkbox/dist/packages/react/checkbox/src/Checkbox.tsx"],
  "sourcesContent": ["export { usePrevious } from './usePrevious';\n", "import * as React from 'react';\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef({ value, previous: value });\n\n  // We compare values before making an update to ensure that\n  // a change has been made. This ensures the previous value is\n  // persisted correctly between renders.\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\n\nexport { usePrevious };\n", "export { useSize } from './useSize';\n", "/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\nfunction useSize(element: HTMLElement | null) {\n  const [size, setSize] = React.useState<{ width: number; height: number } | undefined>(undefined);\n\n  useLayoutEffect(() => {\n    if (element) {\n      // provide size as early as possible\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n\n        // Since we only observe the one element, we don't need to loop over the\n        // array\n        if (!entries.length) {\n          return;\n        }\n\n        const entry = entries[0];\n        let width: number;\n        let height: number;\n\n        if ('borderBoxSize' in entry) {\n          const borderSizeEntry = entry['borderBoxSize'];\n          // iron out differences between browsers\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize['inlineSize'];\n          height = borderSize['blockSize'];\n        } else {\n          // for browsers that don't support `borderBoxSize`\n          // we calculate it ourselves to get the correct border box.\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n\n        setSize({ width, height });\n      });\n\n      resizeObserver.observe(element, { box: 'border-box' });\n\n      return () => resizeObserver.unobserve(element);\n    } else {\n      // We only want to reset to `undefined` when the element becomes `null`,\n      // not if it changes to another element.\n      setSize(undefined);\n    }\n  }, [element]);\n\n  return size;\n}\n\nexport { useSize };\n", "export {\n  Label,\n  //\n  Root,\n  //\n  useLabelContext,\n} from './Label';\nexport type { LabelProps } from './Label';\n", "import * as React from 'react';\nimport { createContext } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useId } from '@radix-ui/react-id';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Label\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Label';\n\ntype LabelContextValue = { id?: string; controlRef: React.MutableRefObject<HTMLElement | null> };\nconst [LabelProvider, useLabelContextImpl] = createContext<LabelContextValue>(NAME, {\n  id: undefined,\n  controlRef: { current: null },\n});\n\ntype LabelElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface LabelProps extends PrimitiveSpanProps {\n  htmlFor?: string;\n}\n\nconst Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef) => {\n  const { htmlFor, id: idProp, ...labelProps } = props;\n  const controlRef = React.useRef<HTMLElement | null>(null);\n  const ref = React.useRef<HTMLSpanElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const id = useId(idProp);\n\n  React.useEffect(() => {\n    if (htmlFor) {\n      const element = document.getElementById(htmlFor);\n      const label = ref.current;\n      if (label && element) {\n        const getAriaLabel = () => element.getAttribute('aria-labelledby');\n        const ariaLabelledBy = [id, getAriaLabel()].filter(Boolean).join(' ');\n        element.setAttribute('aria-labelledby', ariaLabelledBy);\n        controlRef.current = element;\n        return () => {\n          /**\n           * We get the latest attribute value because at the time that this cleanup fires,\n           * the values from the closure may have changed.\n           */\n          const ariaLabelledBy = getAriaLabel()?.replace(id, '');\n          if (ariaLabelledBy === '') {\n            element.removeAttribute('aria-labelledby');\n          } else if (ariaLabelledBy) {\n            element.setAttribute('aria-labelledby', ariaLabelledBy);\n          }\n        };\n      }\n    }\n  }, [id, htmlFor]);\n\n  return (\n    <LabelProvider id={id} controlRef={controlRef}>\n      <Primitive.span\n        role=\"label\"\n        id={id}\n        {...labelProps}\n        ref={composedRefs}\n        onMouseDown={(event) => {\n          props.onMouseDown?.(event);\n          // prevent text selection when double clicking label\n          if (!event.defaultPrevented && event.detail > 1) event.preventDefault();\n        }}\n        onClick={(event) => {\n          props.onClick?.(event);\n          if (!controlRef.current || event.defaultPrevented) return;\n          const isClickingControl = controlRef.current.contains(event.target as Node);\n          // Ensure event was generated by a user action\n          // https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted\n          const isUserClick = event.isTrusted === true;\n          /**\n           * When a label is wrapped around the control it labels, we trigger the appropriate events\n           * on the control when the label is clicked. We do nothing if the user is already clicking the\n           * control inside the label.\n           */\n          if (!isClickingControl && isUserClick) {\n            controlRef.current.click();\n            controlRef.current.focus();\n          }\n        }}\n      />\n    </LabelProvider>\n  );\n});\n\nLabel.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst useLabelContext = (element?: HTMLElement | null) => {\n  const context = useLabelContextImpl('LabelConsumer');\n  const { controlRef } = context;\n\n  React.useEffect(() => {\n    if (element) controlRef.current = element;\n  }, [element, controlRef]);\n\n  return context.id;\n};\n\nconst Root = Label;\n\nexport {\n  Label,\n  //\n  Root,\n  //\n  useLabelContext,\n};\nexport type { LabelProps };\n", "export {\n  createCheckboxScope,\n  //\n  Checkbox,\n  CheckboxIndicator,\n  //\n  Root,\n  Indicator,\n} from './Checkbox';\nexport type { CheckboxProps, CheckboxIndicatorProps } from './Checkbox';\n", "import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { useLabelContext } from '@radix-ui/react-label';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Checkbox\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_NAME = 'Checkbox';\n\ntype ScopedProps<P> = P & { __scopeCheckbox?: Scope };\nconst [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);\n\ntype CheckedState = boolean | 'indeterminate';\n\ntype CheckboxContextValue = {\n  state: CheckedState;\n  disabled?: boolean;\n};\n\nconst [CheckboxProvider, useCheckboxContext] =\n  createCheckboxContext<CheckboxContextValue>(CHECKBOX_NAME);\n\ntype CheckboxElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface CheckboxProps extends Omit<PrimitiveButtonProps, 'checked' | 'defaultChecked'> {\n  checked?: CheckedState;\n  defaultChecked?: CheckedState;\n  required?: boolean;\n  onCheckedChange?(checked: CheckedState): void;\n}\n\nconst Checkbox = React.forwardRef<CheckboxElement, CheckboxProps>(\n  (props: ScopedProps<CheckboxProps>, forwardedRef) => {\n    const {\n      __scopeCheckbox,\n      'aria-labelledby': ariaLabelledby,\n      name,\n      checked: checkedProp,\n      defaultChecked,\n      required,\n      disabled,\n      value = 'on',\n      onCheckedChange,\n      ...checkboxProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const labelId = useLabelContext(button);\n    const labelledBy = ariaLabelledby || labelId;\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? Boolean(button.closest('form')) : true;\n    const [checked = false, setChecked] = useControllableState({\n      prop: checkedProp,\n      defaultProp: defaultChecked,\n      onChange: onCheckedChange,\n    });\n\n    return (\n      <CheckboxProvider scope={__scopeCheckbox} state={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"checkbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          aria-labelledby={labelledBy}\n          aria-required={required}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...checkboxProps}\n          ref={composedRefs}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            // According to WAI ARIA, Checkboxes don't activate on enter keypress\n            if (event.key === 'Enter') event.preventDefault();\n          })}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            setChecked((prevChecked) => (isIndeterminate(prevChecked) ? true : !prevChecked));\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if checkbox is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect checkbox updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n          />\n        )}\n      </CheckboxProvider>\n    );\n  }\n);\n\nCheckbox.displayName = CHECKBOX_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * CheckboxIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'CheckboxIndicator';\n\ntype CheckboxIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface CheckboxIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst CheckboxIndicator = React.forwardRef<CheckboxIndicatorElement, CheckboxIndicatorProps>(\n  (props: ScopedProps<CheckboxIndicatorProps>, forwardedRef) => {\n    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;\n    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);\n    return (\n      <Presence present={forceMount || isIndeterminate(context.state) || context.state === true}>\n        <Primitive.span\n          data-state={getState(context.state)}\n          data-disabled={context.disabled ? '' : undefined}\n          {...indicatorProps}\n          ref={forwardedRef}\n          style={{ pointerEvents: 'none', ...props.style }}\n        />\n      </Presence>\n    );\n  }\n);\n\nCheckboxIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = Radix.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: CheckedState;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      input.indeterminate = isIndeterminate(checked);\n      setChecked.call(input, isIndeterminate(checked) ? false : checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  return (\n    <input\n      type=\"checkbox\"\n      aria-hidden\n      defaultChecked={isIndeterminate(checked) ? false : checked}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nconst Root = Checkbox;\nconst Indicator = CheckboxIndicator;\n\nexport {\n  createCheckboxScope,\n  //\n  Checkbox,\n  CheckboxIndicator,\n  //\n  Root,\n  Indicator,\n};\nexport type { CheckboxProps, CheckboxIndicatorProps };\n"],
  "mappings": "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",
  "names": ["usePrevious", "value", "ref", "React", "previous", "current", "useSize", "element", "size", "setSize", "React", "undefined", "useLayoutEffect", "width", "offsetWidth", "height", "offsetHeight", "resizeObserver", "ResizeObserver", "entries", "Array", "isArray", "length", "entry", "borderSizeEntry", "borderSize", "observe", "box", "unobserve", "NAME", "LabelProvider", "useLabelContextImpl", "createContext", "id", "undefined", "controlRef", "current", "Label", "React", "props", "forwardedRef", "idProp", "labelProps", "ref", "composedRefs", "useComposedRefs", "useId", "htmlFor", "element", "document", "getElementById", "label", "getAriaLabel", "getAttribute", "ariaLabelledBy", "filter", "Boolean", "join", "setAttribute", "replace", "removeAttribute", "$7V4JZ$createElement", "event", "onMouseDown", "defaultPrevented", "detail", "preventDefault", "onClick", "isClickingControl", "contains", "target", "isUserClick", "isTrusted", "click", "focus", "useLabelContext", "context", "CHECKBOX_NAME", "createCheckboxContext", "createCheckboxScope", "createContextScope", "CheckboxProvider", "useCheckboxContext", "Checkbox", "React", "props", "forwardedRef", "ariaLabelledby", "checked", "checkedProp", "checkboxProps", "button", "setButton", "composedRefs", "useComposedRefs", "node", "labelId", "useLabelContext", "labelledBy", "hasConsumerStoppedPropagationRef", "isFormControl", "Boolean", "closest", "setChecked", "useControllableState", "prop", "defaultProp", "defaultChecked", "onChange", "onCheckedChange", "$1bpvS$createElement", "__scopeCheckbox", "isIndeterminate", "required", "getState", "disabled", "undefined", "composeEventHandlers", "onKeyDown", "event", "key", "preventDefault", "onClick", "prevChecked", "current", "isPropagationStopped", "stopPropagation", "transform", "INDICATOR_NAME", "CheckboxIndicator", "indicatorProps", "context", "forceMount", "state", "pointerEvents", "style", "BubbleInput", "inputProps", "ref", "usePrevious", "controlSize", "useSize", "control", "input", "inputProto", "window", "HTMLInputElement", "prototype", "descriptor", "Object", "getOwnPropertyDescriptor", "set", "Event", "indeterminate", "call", "dispatchEvent", "bubbles", "position", "opacity", "margin", "Root", "Indicator"]
}
